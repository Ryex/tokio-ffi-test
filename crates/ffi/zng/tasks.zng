use crate::task::TaskSpawnOptions as TaskSpawnOptions;
use crate::task::TaskOptions as TaskOptions;
use crate::task::TaskMetadata as TaskMetadata;
use crate::task::EventType as EventType;
use crate::task::TaskId as TaskId;
use crate::task::TaskError as TaskError;
use crate::task::TaskContext as TaskContext;
use crate::task::TaskProgress as TaskProgress;

use crate::task::Task as Task;
use crate::task::TaskSpawnError as TaskSpawnError;
use crate::task::FfiError as FfiError;
use crate::task::IoError as IoError;

use crate::ffi::CxxAny as CxxAny;

use ::std::result::Result as Result;
use ::std::option::Option as Option;

use ::std::string::String as String;


mod crate::task {

    type TaskSpawnError {
        #layout(size = 24, align = 8);
        fn to_string(&self) -> String;
    }

    type TaskError {
        #layout(size = 40, align = 8);

        constructor TaskCanceled;
        constructor Error(FfiError);

        fn to_string(&self) -> String;
        fn as_task_canceled(&self) -> Option<&TaskError>;
        fn as_join_error(&self) -> Option<& ::tokio::task::JoinError>;
        fn as_spawn_error(&self) -> Option<&TaskSpawnError>;
        fn as_error(&self) -> Option<&FfiError>;
    }

    type FfiError {
        #layout(size = 40, align = 8);

        constructor Exception(crate::ffi::CxxException);

        fn to_string(&self) -> String;

        fn as_exception(&self) -> Option<&crate::ffi::CxxException>;
        fn as_io(&self) -> Option<&IoError>;
    }

    type IoError {
        #layout(size = 32, align = 8);
        fn to_string(&self) -> String;
    }

    type SubscriptionHandle {
        #layout(size = 8, align = 8);
    }

    type TaskManager {
        #layout(size = 32, align = 8);

        fn new() -> TaskManager;

        fn new_blocking<(), Box<dyn Fn() -> Result<(), TaskError> + Send>>(
            &self,
            Box<dyn Fn() -> Result<
                (),
                TaskError> + Send
            >,
            Option<TaskSpawnOptions>
        ) -> Box<Task<()>>;

        fn new_blocking_with_ctx<
            (),
            Box<dyn Fn(
                &TaskContext
            ) -> Result<(), TaskError> + Send>
        >(
            &self,
            Box<dyn Fn(
                &TaskContext
            ) -> Result<(), TaskError> + Send>,
            Option<TaskSpawnOptions>,
        ) -> Box<Task<()>>;


        fn new_blocking<
            CxxAny,
            Box<dyn Fn() -> Result<
                CxxAny,
                TaskError
            > + Send>
        >(
            &self,
            Box<dyn Fn() -> Result<
                CxxAny,
                TaskError
            > + Send>,
            Option<TaskSpawnOptions>
        ) -> Box<Task<CxxAny>>;

        fn new_blocking_with_ctx<
            CxxAny,
            Box<dyn Fn(
                &TaskContext
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>
        >(
            &self,
            Box<dyn Fn(
                &TaskContext
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>,
            Option<TaskSpawnOptions>,
        ) -> Box<Task<CxxAny>>;

        fn subscribe<
            Box<dyn Fn(TaskId, &crate::task::TaskOptions) -> bool + Send>,
            Box<dyn Fn(&TaskMetadata) + Send>
        >(
            &self,
            EventType,
            Option<Box<dyn Fn(TaskId, &crate::task::TaskOptions) -> bool + Send>>,
            Box<dyn Fn(&TaskMetadata) + Send>
        ) -> SubscriptionHandle;

        fn unsubscribe(&self, &SubscriptionHandle);
    }

    type Task<()> {
        #layout(size = 96, align = 8);

        fn id(&self) -> TaskId;
        fn manager(&self) -> &TaskManager;
        fn is_finished(&self) -> bool;
        fn is_canceled(&self) -> bool;
        fn cancel(&self);
        fn on_progress(
            &self,
            Box<dyn Fn(&TaskProgress) + Send>
        ) -> Option<::tokio::task::AbortHandle>;

        fn then<
            (),
            Box<dyn Fn(
                Result<(), TaskError>
            ) -> Result<(), TaskError> + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<(), TaskError>
            ) -> Result<(), TaskError> + Send>,
            Option<TaskSpawnOptions>
        ) -> Result<Box<Task<()>>, TaskSpawnError>;
        
        fn then_with_ctx<
            (),
            Box<dyn Fn(
                Result<(), TaskError>,
                &TaskContext
            ) -> Result<(), TaskError> + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<(), TaskError>,
                &TaskContext
            ) -> Result<(), TaskError> + Send>,
            Option<TaskSpawnOptions>
        ) -> Result<Box<Task<()>>, TaskSpawnError>;

        fn then<
            CxxAny,
            Box<dyn Fn(
                Result<(), TaskError>
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<(), TaskError>
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>,
            Option<TaskSpawnOptions>
        ) -> Result<
            Box<Task<CxxAny>>,
            TaskSpawnError
        >;


        fn then_with_ctx<
            CxxAny,
            Box<dyn Fn(
                Result<(), TaskError>,
                &TaskContext
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<(), TaskError>,
                &TaskContext
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>,
            Option<TaskSpawnOptions>
        ) -> Result<
            Box<Task<CxxAny>>,
            TaskSpawnError
        >;
    }


    type Task<CxxAny> {
        #layout(size = 96, align = 8);
        fn id(&self) -> TaskId;
        fn manager(&self) -> &TaskManager;
        fn is_finished(&self) -> bool;
        fn is_canceled(&self) -> bool;
        fn cancel(&self);
        fn on_progress(
            &self,
            Box<dyn Fn(&TaskProgress) + Send>
        ) -> Option<::tokio::task::AbortHandle>;

        fn then<
            (),
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >
            ) -> Result<(), TaskError> + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >
            ) -> Result<(), TaskError> + Send>,
            Option<TaskSpawnOptions>
        ) -> Result<Box<Task<()>>, TaskSpawnError>;
        
        fn then_with_ctx<
            (),
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >,
                &TaskContext
            ) -> Result<(), TaskError> + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >,
                &TaskContext
            ) -> Result<(), TaskError> + Send>,
            Option<TaskSpawnOptions>
        ) -> Result<Box<Task<()>>, TaskSpawnError>;

        fn then<
            CxxAny,
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>,
            Option<TaskSpawnOptions>
        ) -> Result<
            Box<Task<CxxAny>>,
            TaskSpawnError
        >;


        fn then_with_ctx<
            CxxAny,
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >,
                &TaskContext
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >,
                &TaskContext
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>,
            Option<TaskSpawnOptions>
        ) -> Result<
            Box<Task<CxxAny>>,
            TaskSpawnError
        >;
    }
}

mod ::std {
    mod result {
        type Result<Box<Task<()>>, TaskSpawnError> {
            #layout(size = 24, align = 8);

            constructor Ok(Box<Task<()>>);
            constructor Err(TaskSpawnError);
            
            fn is_ok(&self) -> bool;
            fn is_err(&self) -> bool;
            fn unwrap(self) -> Box<Task<()>>;
            fn err(self) -> Option<TaskSpawnError>;
        }

        type Result<(), TaskError> {
            #layout(size = 40, align = 8);

            constructor Ok(());
            constructor Err(TaskError);
            
            fn is_ok(&self) -> bool;
            fn is_err(&self) -> bool;
            fn unwrap(self) -> ();
            fn err(self) -> Option<TaskError>;
        }

        type Result<
            Box<Task<CxxAny>>,
            TaskSpawnError
        > {
            #layout(size = 24, align = 8);

            constructor Ok(Box<Task<CxxAny>>);
            constructor Err(TaskSpawnError);
            
            fn is_ok(&self) -> bool;
            fn is_err(&self) -> bool;
            fn unwrap(self) -> Box<Task<CxxAny>>;
            fn err(self) -> Option<TaskSpawnError>;
        }

        type Result<CxxAny, TaskError> {
            #layout(size = 40, align = 8);

            constructor Ok(CxxAny);
            constructor Err(TaskError);

            fn is_ok(&self) -> bool;
            fn is_err(&self) -> bool;
            fn unwrap(self) -> CxxAny;
            fn err(self) -> Option<TaskError>;
        }
    }
}

type Box<Task<()>> {
    #layout(size = 8, align = 8);
    fn as_ref(&self) -> &crate::task::Task<()>;
}

type Box<Task<CxxAny>> {
    #layout(size = 8, align = 8);
    fn as_ref(&self) -> &crate::task::Task<CxxAny>;
}

