// ---------------------------------------
// Functions / Closures passed from C++
// ---------------------------------------

use crate::task::TaskOptions as TaskOptions;
use crate::task::TaskId as TaskId;
use crate::task::TaskError as TaskError;
use crate::task::TaskContext as TaskContext;
use crate::task::TaskProgress as TaskProgress;

use crate::task::Task as Task;
use crate::task::TaskSpawnError as TaskSpawnError;
use crate::task::FfiError as FfiError;
use crate::task::IoError as IoError;

use crate::ffi::CxxAny as CxxAny;

use ::std::result::Result as Result;
use ::std::option::Option as Option;

use ::std::string::String as String;

type Box<dyn Fn() -> Result<(), TaskError> + Send> {
    #layout(size = 16, align = 8);
}

type Box<dyn Fn(&TaskContext) -> Result<(), TaskError> + Send> {
    #layout(size = 16, align = 8);
}

type Box<dyn Fn() -> Result<CxxAny, TaskError> + Send> {
    #layout(size = 16, align = 8);
}

type Box<dyn Fn(&TaskContext) -> Result<CxxAny, TaskError> + Send> {
    #layout(size = 16, align = 8);
}

type Box<dyn Fn(Result<(), TaskError>) -> Result<(), TaskError> + Send> {
    #layout(size = 16, align = 8);
}

type Box<dyn Fn(Result<(), TaskError>, &TaskContext) -> Result<(), TaskError> + Send> {
    #layout(size = 16, align = 8);
}

type Box<dyn Fn(Result<(), TaskError>) -> Result<CxxAny, TaskError> + Send> {
    #layout(size = 16, align = 8);
}

type Box<dyn Fn(Result<(), TaskError>, &TaskContext) -> Result<CxxAny, TaskError> + Send> {
    #layout(size = 16, align = 8);
}


type Box<dyn Fn(Result<CxxAny, TaskError>) -> Result<(), TaskError> + Send> {
    #layout(size = 16, align = 8);
}

type Box<dyn Fn(Result<CxxAny, TaskError>, &TaskContext) -> Result<(), TaskError> + Send> {
    #layout(size = 16, align = 8);
}

type Box<dyn Fn(Result<CxxAny, TaskError>) -> Result<CxxAny, TaskError> + Send> {
    #layout(size = 16, align = 8);
}

type Box<dyn Fn(Result<CxxAny, TaskError>, &TaskContext) -> Result<CxxAny, TaskError> + Send> {
    #layout(size = 16, align = 8);
}

type Box<dyn Fn(&TaskProgress) + Send> {
    #layout(size = 16, align = 8);
}

// ----------------------
// Optionals
// -----------------------

mod std {
    mod option {
        type Option<TaskId> {
            #layout(size = 8, align = 8);
            constructor None;
            constructor Some(TaskId);

            fn is_some(&self) -> bool;
            fn unwrap(self) -> TaskId;
            fn expect(self, &str) -> TaskId;
        }

        type Option<TaskOptions> {
            #layout(size = 72, align = 8);
            wellknown_traits(Debug);
            
            constructor None;
            constructor Some(TaskOptions);

            fn is_some(&self) -> bool;
            fn unwrap(self) -> TaskOptions;
            fn expect(self, &str) -> TaskOptions;
        }

        type Option<::tokio::task::AbortHandle> {
            #layout(size = 8, align = 8);
            fn is_some(&self) -> bool;
            fn unwrap(self) -> ::tokio::task::AbortHandle;
            fn expect(self, &str) -> ::tokio::task::AbortHandle;
            fn as_ref(&self) -> Option<&::tokio::task::AbortHandle>;
        }

        type Option<&::tokio::task::AbortHandle> {
            #layout(size = 8, align = 8);
            fn is_some(&self) -> bool;
            fn unwrap(self) -> &::tokio::task::AbortHandle;
            fn expect(self, &str) -> &::tokio::task::AbortHandle;
        }

        type Option<&::tokio::task::JoinError> {
            #layout(size = 8, align = 8);
            fn is_some(&self) -> bool;
            fn unwrap(self) -> &::tokio::task::JoinError;
            fn expect(self, &str) -> &::tokio::task::JoinError;
        }

        type Option<&TaskError> {
            #layout(size = 8, align = 8);
            fn is_some(&self) -> bool;
            fn unwrap(self) -> &TaskError;
            fn expect(self, &str) -> &TaskError;
        }

        type Option<TaskError> {
            #layout(size = 40, align = 8);
            fn is_some(&self) -> bool;
            fn unwrap(self) -> TaskError;
            fn expect(self, &str) -> TaskError;
            fn as_ref(&self) -> Option<&TaskError>;
        }

        type Option<&TaskSpawnError> {
            #layout(size = 8, align = 8);
            fn is_some(&self) -> bool;
            fn unwrap(self) -> &TaskSpawnError;
            fn expect(self, &str) -> &TaskSpawnError;
        }

        type Option<TaskSpawnError> {
            #layout(size = 24, align = 8);
            fn is_some(&self) -> bool;
            fn unwrap(self) -> TaskSpawnError;
            fn expect(self, &str) -> TaskSpawnError;
            fn as_ref(&self) -> Option<&TaskSpawnError>;
        }

        type Option<&FfiError> {
            #layout(size = 8, align = 8);
            fn is_some(&self) -> bool;
            fn unwrap(self) -> &FfiError;
            fn expect(self, &str) -> &FfiError;
        }

        type Option<&crate::ffi::CxxException>{
            #layout(size = 8, align = 8);
            fn is_some(&self) -> bool;
            fn unwrap(self) -> &crate::ffi::CxxException;
            fn expect(self, &str) -> &crate::ffi::CxxException;
        }

        type Option<&IoError> {
            #layout(size = 8, align = 8);
            fn is_some(&self) -> bool;
            fn unwrap(self) -> &IoError;
            fn expect(self, &str) -> &IoError;
        }
    }
}


mod crate::task {

    type TaskSpawnError {
        #layout(size = 24, align = 8);
        fn to_string(&self) -> String;
    }

    type TaskError {
        #layout(size = 40, align = 8);

        constructor Error(FfiError);

        fn to_string(&self) -> String;
        fn as_task_canceled(&self) -> Option<&TaskError>;
        fn as_join_error(&self) -> Option<& ::tokio::task::JoinError>;
        fn as_spawn_error(&self) -> Option<&TaskSpawnError>;
        fn as_error(&self) -> Option<&FfiError>;
    }

    type FfiError {
        #layout(size = 40, align = 8);

        constructor External(crate::ffi::CxxException);

        fn to_string(&self) -> String;

        fn as_external(&self) -> Option<&crate::ffi::CxxException>;
        fn as_io(&self) -> Option<&IoError>;
    }

    type IoError {
        #layout(size = 32, align = 8);
        fn to_string(&self) -> String;
    }

    type TaskManager {
        #layout(size = 16, align = 8);

        fn new() -> TaskManager;

        fn new_blocking<(), Box<dyn Fn() -> Result<(), TaskError> + Send>>(
            &self,
            Box<dyn Fn() -> Result<
                (),
                TaskError> + Send
            >,
            Option<TaskOptions>
        ) -> Box<Task<()>>;

        fn new_blocking_with_ctx<
            (),
            Box<dyn Fn(
                &TaskContext
            ) -> Result<(), TaskError> + Send>
        >(
            &self,
            Box<dyn Fn(
                &TaskContext
            ) -> Result<(), TaskError> + Send>,
            Option<TaskOptions>,
        ) -> Box<Task<()>>;


        fn new_blocking<
            CxxAny,
            Box<dyn Fn() -> Result<
                CxxAny,
                TaskError
            > + Send>
        >(
            &self,
            Box<dyn Fn() -> Result<
                CxxAny,
                TaskError
            > + Send>,
            Option<TaskOptions>
        ) -> Box<Task<CxxAny>>;

        fn new_blocking_with_ctx<
            CxxAny,
            Box<dyn Fn(
                &TaskContext
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>
        >(
            &self,
            Box<dyn Fn(
                &TaskContext
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>,
            Option<TaskOptions>,
        ) -> Box<Task<CxxAny>>;
    }


    type Task<()> {
        #layout(size = 72, align = 8);

        fn id(&self) -> TaskId;
        fn manager(&self) -> &TaskManager;
        fn is_finished(&self) -> bool;
        fn is_canceled(&self) -> bool;
        fn cancel(&self);
        fn on_progress(
            &self,
            Box<dyn Fn(&TaskProgress) + Send>
        ) -> Option<::tokio::task::AbortHandle>;

        fn then<
            (),
            Box<dyn Fn(
                Result<(), TaskError>
            ) -> Result<(), TaskError> + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<(), TaskError>
            ) -> Result<(), TaskError> + Send>,
            Option<TaskOptions>
        ) -> Result<Box<Task<()>>, TaskSpawnError>;
        
        fn then_with_ctx<
            (),
            Box<dyn Fn(
                Result<(), TaskError>,
                &TaskContext
            ) -> Result<(), TaskError> + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<(), TaskError>,
                &TaskContext
            ) -> Result<(), TaskError> + Send>,
            Option<TaskOptions>
        ) -> Result<Box<Task<()>>, TaskSpawnError>;

        fn then<
            CxxAny,
            Box<dyn Fn(
                Result<(), TaskError>
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<(), TaskError>
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>,
            Option<TaskOptions>
        ) -> Result<
            Box<Task<CxxAny>>,
            TaskSpawnError
        >;


        fn then_with_ctx<
            CxxAny,
            Box<dyn Fn(
                Result<(), TaskError>,
                &TaskContext
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<(), TaskError>,
                &TaskContext
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>,
            Option<TaskOptions>
        ) -> Result<
            Box<Task<CxxAny>>,
            TaskSpawnError
        >;
    }


    type Task<CxxAny> {
        #layout(size = 72, align = 8);
        fn id(&self) -> TaskId;
        fn manager(&self) -> &TaskManager;
        fn is_finished(&self) -> bool;
        fn is_canceled(&self) -> bool;
        fn cancel(&self);
        fn on_progress(
            &self,
            Box<dyn Fn(&TaskProgress) + Send>
        ) -> Option<::tokio::task::AbortHandle>;

        fn then<
            (),
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >
            ) -> Result<(), TaskError> + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >
            ) -> Result<(), TaskError> + Send>,
            Option<TaskOptions>
        ) -> Result<Box<Task<()>>, TaskSpawnError>;
        
        fn then_with_ctx<
            (),
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >,
                &TaskContext
            ) -> Result<(), TaskError> + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >,
                &TaskContext
            ) -> Result<(), TaskError> + Send>,
            Option<TaskOptions>
        ) -> Result<Box<Task<()>>, TaskSpawnError>;

        fn then<
            CxxAny,
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>,
            Option<TaskOptions>
        ) -> Result<
            Box<Task<CxxAny>>,
            TaskSpawnError
        >;


        fn then_with_ctx<
            CxxAny,
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >,
                &TaskContext
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>
        > (
            &self,
            Box<dyn Fn(
                Result<
                    CxxAny,
                    TaskError
                >,
                &TaskContext
            ) -> Result<
                CxxAny,
                TaskError
            > + Send>,
            Option<TaskOptions>
        ) -> Result<
            Box<Task<CxxAny>>,
            TaskSpawnError
        >;
    }
}

mod ::std {
    mod result {
        type Result<Box<Task<()>>, TaskSpawnError> {
            #layout(size = 24, align = 8);

            constructor Ok(Box<Task<()>>);
            constructor Err(TaskSpawnError);
            
            fn is_ok(&self) -> bool;
            fn is_err(&self) -> bool;
            fn unwrap(self) -> Box<Task<()>>;
            fn err(self) -> Option<TaskSpawnError>;
        }

        type Result<(), TaskError> {
            #layout(size = 40, align = 8);

            constructor Ok(());
            constructor Err(TaskError);
            
            fn is_ok(&self) -> bool;
            fn is_err(&self) -> bool;
            fn unwrap(self) -> ();
            fn err(self) -> Option<TaskError>;
        }

        type Result<
            Box<Task<CxxAny>>,
            TaskSpawnError
        > {
            #layout(size = 24, align = 8);

            constructor Ok(Box<Task<CxxAny>>);
            constructor Err(TaskSpawnError);
            
            fn is_ok(&self) -> bool;
            fn is_err(&self) -> bool;
            fn unwrap(self) -> Box<Task<CxxAny>>;
            fn err(self) -> Option<TaskSpawnError>;
        }

        type Result<CxxAny, TaskError> {
            #layout(size = 40, align = 8);

            constructor Ok(CxxAny);
            constructor Err(TaskError);

            fn is_ok(&self) -> bool;
            fn is_err(&self) -> bool;
            fn unwrap(self) -> CxxAny;
            fn err(self) -> Option<TaskError>;
        }
    }
}

type Box<Task<()>> {
    #layout(size = 8, align = 8);
    fn as_ref(&self) -> &crate::task::Task<()>;
}

type Box<Task<CxxAny>> {
    #layout(size = 8, align = 8);
    fn as_ref(&self) -> &crate::task::Task<CxxAny>;
}

