type str {
    wellknown_traits(?Sized);

    fn as_ptr(&self) -> *const u8;
    fn len(&self) -> usize;
    fn to_string(&self) -> ::std::string::String;
    fn to_owned(&self) -> ::std::string::String;
}

type bool {
    #layout(size = 1, align = 1);
    wellknown_traits(Copy);
}

type [&str] {
    wellknown_traits(?Sized);

    fn len(&self) -> usize;
    fn to_vec(&self) -> ::std::vec::Vec<&str>;
}

type [::std::string::String] {
    wellknown_traits(?Sized);

    fn len(&self) -> usize;
    fn get(&self, usize) -> ::std::option::Option<&::std::string::String>;
    fn to_vec(&self) -> ::std::vec::Vec<::std::string::String>;
}

mod ::std::slice {
    fn from_raw_parts<u64>(*const u64, usize) -> &[u64];
    fn from_raw_parts<u16>(*const u16, usize) -> &[u16];
    fn from_raw_parts<u8>(*const u8, usize) -> &[u8];
}

/// for strings
mod std {

    mod string {
        type String {
            #layout(size = 24, align = 8);
          
            fn as_bytes(&self) -> &[u8];
            fn as_mut_str(&mut self) -> &mut str;
            fn as_str(&self) -> &str;
            fn push_str(&mut self, &str);
            fn capacity(&self) -> usize;
            fn clear(&mut self);
            fn reserve(&mut self, usize);
            fn insert_str(&mut self, usize, &str);
            fn len(&self) -> usize;
            fn is_empty(&self) -> bool;

            fn from_utf8(::std::vec::Vec<u8>) -> ::std::result::Result<::std::string::String, FromUtf8Error>;
            fn from_utf16(&[u16]) -> ::std::result::Result<::std::string::String, FromUtf16Error>;
            
        }
    }
    
    mod option {

        type Option<&::std::string::String> {
            #layout(size = 8, align = 8);

            fn unwrap(self) -> &::std::string::String;
        }

        type Option<::std::string::String> {
            #layout(size = 24, align = 8);

            constructor None;
            constructor Some(::std::string::String);

            fn unwrap(self) -> ::std::string::String;
        }
    }

    mod result {
        type Result<::std::string::String, ::std::string::FromUtf8Error> {
            #layout(size = 40, align = 8);
            fn expect(self, &str) -> ::std::string::String;
        }
        type Result<::std::string::String, ::std::string::FromUtf16Error> {
            #layout(size = 24, align = 8);
            fn expect(self, &str) -> ::std::string::String;
        }
        type Result<&str, ::std::str::Utf8Error> {
            #layout(size = 24, align = 8);

            fn expect(self, &str) -> &str;
        }
    }
}

/// for HashSet<String>
mod std {

    type collections::HashSet<::std::string::String> {
        #layout(size = 48, align = 8);
        
        fn iter(&self) -> ::std::collections::hash_set::Iter<::std::string::String>;
        fn len(&self) -> usize;
        fn capacity(&self) -> usize;
        fn is_empty(&self) -> bool;
        fn clear(&mut self);
        fn reserve(&mut self, usize);
        fn contains(&self, &str) -> bool;
        fn insert(&mut self, ::std::string::String) -> bool;
        fn remove(&mut self, &str) -> bool;
    }
    
    type collections::hash_set::Iter<string::String> {
        #layout(size = 40, align = 8);
        fn len(&self) -> usize;
        fn size_hint(&self) -> (usize, ::std::option::Option<usize>);
        fn count(self) -> usize;
        fn next(&mut self) -> ::std::option::Option<&string::String>;
    }
}


type (usize, ::std::option::Option<usize>) {
    #layout(size = 24, align = 8);
    wellknown_traits(Debug);

    fn lower(&self) -> usize use crate::ffi::SizeHintExt;
    fn upper(&self) -> ::std::option::Option<usize> use crate::ffi::SizeHintExt;
}

mod ::std {
    mod ffi {
        type OsString {
            #layout(size = 24, align = 8);

            fn clone(&self) -> ::std::ffi::OsString;
            fn as_os_str(&self) -> &::std::ffi::OsStr;
            fn into_encoded_bytes(self) -> ::std::vec::Vec<u8>;

            fn is_empty(&self) -> bool deref ::std::ffi::OsStr; 
            fn to_string_lossy(&self) -> ::std::borrow::Cow<str> deref ::std::ffi::OsStr;
            fn to_os_string(&self) -> OsString deref ::std::ffi::OsStr;
            fn as_encoded_bytes(&self) -> &[u8] deref ::std::ffi::OsStr;
            
        }
        
        type OsStr {
            wellknown_traits(?Sized);
            
            fn is_empty(&self) -> bool;
            fn to_string_lossy(&self) -> ::std::borrow::Cow<str>;
            fn to_os_string(&self) -> ::std::ffi::OsString;
            fn as_encoded_bytes(&self) -> &[u8];
        }

        type CStr {
            wellknown_traits(?Sized);

            fn from_ptr(*const i8) -> &::std::ffi::CStr;
            fn to_str(&self) -> ::std::result::Result<&str, ::std::str::Utf8Error>;
        }
    }

    mod borrow {
        type Cow<str> {
            #layout(size = 24, align = 8);

            fn as_ptr(&self) -> *const u8 deref str;
            fn len(&self) -> usize deref str;
            fn to_string(&self) -> ::std::string::String deref str;
            fn to_owned(&self) -> ::std::string::String deref str;
        }
    }
}
