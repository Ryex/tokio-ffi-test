/// for strings
mod std {

    mod string {
        type String {
            #layout(size = 24, align = 8);
          
            fn as_bytes(&self) -> &[u8];
            fn as_mut_str(&mut self) -> &mut str;
            fn as_str(&self) -> &str;
            fn push_str(&mut self, &str);
            fn capacity(&self) -> usize;
            fn clear(&mut self);
            fn reserve(&mut self, usize);
            fn insert_str(&mut self, usize, &str);
            fn len(&self) -> usize;
            fn is_empty(&self) -> bool;

            fn from_utf8(::std::vec::Vec<u8>) -> ::std::result::Result<::std::string::String, FromUtf8Error>;
            fn from_utf16(&[u16]) -> ::std::result::Result<::std::string::String, FromUtf16Error>;
            
        }
    }
    
    mod option {

        type Option<&::std::string::String> {
            #layout(size = 8, align = 8);

            fn unwrap(self) -> &::std::string::String;
        }

        type Option<::std::string::String> {
            #layout(size = 24, align = 8);

            constructor None;
            constructor Some(::std::string::String);

            fn unwrap(self) -> ::std::string::String;
        }
    }

    mod result {
        type Result<::std::string::String, ::std::string::FromUtf8Error> {
            #layout(size = 40, align = 8);
            fn expect(self, &str) -> ::std::string::String;
        }
        type Result<::std::string::String, ::std::string::FromUtf16Error> {
            #layout(size = 24, align = 8);
            fn expect(self, &str) -> ::std::string::String;
        }
        type Result<&str, ::std::str::Utf8Error> {
            #layout(size = 24, align = 8);

            fn expect(self, &str) -> &str;
        }
    }
}
